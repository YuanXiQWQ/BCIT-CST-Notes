 一种可以在传输数据时检测和纠正单个比特错误的编码方式, 基本思想是通过在数据中加入一些额外的比特（校验位），以便在数据出错时能够识别出错误的位置。
### 构建汉明码:
	1. 确定需要多少校验位
		校验位的数量r必须满足:
2<sup>r</sup> ≥ m + r + 1 ( r , m ∈ N<sup>+</sup> )
		其中:
		m = 数据位的数量
		r = 校验位的数量

		假设要传输 4 位的数据 1010, 则 m = 4 ,需要的校验位数量为

2<sup>r</sup> ≥ 4 + r + 1
2<sup>r</sup> - r ≥ 5
r ≥ 3 => r = 3

	2. 给校验值分配位置
	在码字中,校验值通常放在 2^0, 2^1, 2^2, ..., 2^(r-1)的位置
	在例子 1010 中,校验值应放在1, 2, 4位
	原始数据位(Data bits): d1, d2, d3, d4
	校验位(Parity bits):p1, p2, p3
	最终码子结构:p1, p2, d1, p3, d2, d3, d4

	3. 计算校验位的值:
	校验位的值通过数据位计算得出,确保其所覆盖的某些位的异或（XOR）结果满足特定规则
		1. 确认校验位覆盖的位置:
		所有二进制表示中包含它自己位置的比特为 1 的数据位
		例如:
		p1 处于位置 2^0 = 1, 1的二进制为0001, 则 p1 将覆盖所有二进制表示中第一位为 1 的数据位, 如 1(0001), 3(0011), 5(0101), 7(0111)
		p2 处于位置 2^1 = 2(0010),则覆盖第二位为 1 的数据位,如 2(0010), 3(0011), 6(0110), 7(0111)
		p3 处于位置 2^2 = 4(0100),则覆盖 4(0100), 5(0101), 6(0110), 7(0111)

		2. 计算校验位所覆盖位置的XOR
		对于例子 1010, 其最终码子结构为 p1 p2 1 p3 0 1 0
		则计算
		p1 覆盖 1, 3, 5, 7, 对应 p1, 1, 0, 0
		p1 = 1 XOR 0 XOR 0
		p1 = 1 XOR 0
		p1 = 1

		p2 (2,3,6,7) 对应 p2, 1, 1, 0
		p2 = 1 XOR 1 XOR 0
		p2 = 0 XOR 0
		p2 = 0

		p3 (4,5,6,7) 对应 p3, 0, 1, 0
		p3 = 0 XOR 1 XOR 0
		p3 = 1 XOR 0
		p3 = 1

所以最终汉明码的值为 1011010

### 汉明距离(Hamming Distance):
#### 计算:
	两个相同长度的二进制码字中不同位的个数, 表示一个码字变成另一个码字所需要改变的比特位的数量
	例:
	010 和 100 的汉明距离:
	比较位置：
	    第一位：0 和 1（不同）
	    第二位：1 和 0（不同）
	    第三位：0 和 0（相同）
	汉明距离 = 2（不同的位数有两位）

	或者取对应位置之间的异或和
	0101 和 0110 的汉明距离:
		0 XOR 0 = 0
		1 XOR 1 = 0
		0 XOR 1 = 1
		1 XOR 0 = 1
	汉明距离 = 0 + 0 + 1 + 1 = 2

### 意义:
	在纠错码中，汉明距离越大，说明两个码字之间的差异越大。对于一个纠错码集合，如果所有码字之间的最小汉明距离是 d，则该码可以：
		- 检测到 d - 1 个错误
		- 纠正 (d - 1) / 2 个错误

### 汉明码的错误检测与纠正
#### 偶校验(Even Parity): 