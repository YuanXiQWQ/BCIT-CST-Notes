$$
\begin{align}
 & 杂鱼 \heartsuit 杂鱼杂鱼 \heartsuit \textasciitilde \textasciitilde  \\
 & 小 \space Cache \space 的小映射在我的大主存面前真的是杂鱼呢 \heartsuit \\
 & 才映射这么点就不行了嘛 \heartsuit \heartsuit \\
 & 人家还没能满足呢 \space zako \space \heartsuit  \\
 & 在人家喊停之前要狠狠地映射满人家哦 \heartsuit
\end{align}
$$
由于 Cache 保存的是主存某些数据块的副本, 因此 Cache 和主存会存在一定映射关系
## 直接映射 (Direct-Mapped)
- 每个主存块只能放到一个特定的位置
	- $Cache \space 块号 = 主存块号 \space \% \space Cache \space 总块数$
- 例如图 b 中, Cache 共 8 个块
	- 则主存块 1 可以存在 Cache 的 $1 \space \% \space 8 = 1$ 块中
	- 主存块 10 可以存在 Cache 的 $10 \space \% \space 8 = 2$ 块中
- 块内偏移（WORD）：决定地址在 Cache 行中的哪个位置
- 行号（LINE）：决定该地址映射到 Cache 中哪一行
- 标记（TAG）：用于在 LINE 所对应的行中判断该地址是否命中
![[Pasted image 20241208181224.png]]
### 对应关系
**WORD 位数** = $\log_2(\text{每行的字节数}) - \log_2(\text{每个 word 的字节数})$
**LINE 位数** = $\log_2(\text{Cache 行数})$
**TAG 位数** = 总地址位数 - LINE 位数 - WORD 位数

|          **TAG**          |         **LINE**         |        **WORD**         |           **总地址**           |
| :-----------------------: | :----------------------: | :---------------------: | :-------------------------: |
| $\log_{2}{\frac{主存}{缓存}}$ | $\log_{2}{\frac{行}{缓存}}$ | $\log_{2}{\frac{字}{行}}$ | $\log_{2}{\frac{内存}{内存/字}}$ |
### 例题
获得满分所需的强制步骤：
- 使用 $2^n$ 形式进行计算；
- 始终写出完整的计算过程；
- 每一步都要带上单位；
- 如可能，验算。
#### Q1
**TAG，LINE，WORD 各占多少位？**
- 主存：$1 \text{cell}/\text{word}$，总大小为 $1 MB$，$1 \text{byte}/\text{word}$
- Cache：$32$ 行，$8\text{words}/\text{line}$
##### A ：
WORD：
每行 $8={2}^3$ 个字，要 $3$ 位
LINE：
Cache 有 $32=2^{5}$ 行，要 $5$ 位
TAG：
大小为 $1 MB = 2^{20}bytes$，每个字占 $1$ 字节，总地址位 $\frac{20}{1}=20$ 位，则 $TAG=总-WORD-LINE=12$ 位

#### Q2
**TAG，LINE，WORD 各占多少位？**
- 主存：$1 \text{word}/\text{cell}$，总大小为 $1GB$，$4 \text{byte}/\text{word}$
- Cache：直接映射（direct mapped），总容量为 $256KB$，共 $64$ 行
##### A ：
**总地址：**
$2^{30}$ 字节的主存 $\div$ 每个字 $2^2$ 字节 = $2^{28}$ 位地址
→ 所以主存地址总共是 $28$ 位

**LINE：**
Cache 有 $2^6$ 行，需要 $6$ 位来标识每一行  
→ 所以地址格式是 $T - 6 - W$

**TAG：**
计算 TAG（标记）位数：$\log_2(\text{总内存} \div \text{总缓存})$  
$2^{30} \text{byte} \div 2^{18} \text{byte} = 2^{12}$（每个缓存块覆盖 $2^{12}$ 个内存块）  
→ 所以 TAG 是 $12$ 位，地址格式变为 $12 - 6 - W$

**WORD：**
WORD 字段位数 = $28 - 12 - 6 = 10$ 位  
→ 所以 $T - L - W = 12 - 6 - 10$

**验算：**
验证最后的 WORD 字段是否合理：  
Cache 总共 $2^{18}$ 字节，有 $2^6$ 行  
→ 每行 $2^{18} \div 2^6 = 2^{12}$ 字节  
每个 word 是 $2^2$ 字节  
→ 每行 $2^{12} **\div** 2^2 = 2^{10}$ 个 word ✅

最终结论：$T - L - W = 12 - 6 - 10$

#### Q 3：
**TAG，LINE，WORD 各占多少位？**  
- 主存：$1 \text{ word}/\text{cell}$，每个 word 为 $64$ 位（即 $8$ 字节），地址总长度为 $24$ 位  
- Cache：直接映射（direct mapped），总容量为 $1\text{ kB}$，每行大小为 $32$ 字节  
##### A：
**TAG：**  
Tag 大小：$\log_2(\text{总内存} \div \text{总缓存})$  

$2^{24} \text{word} \times 2^{3} \text{bytes/word} = 2^{27} \text{bytes}$
$\frac{2^{27} \text{bytes}}{2^{10} \text{bytes}} = 2^{17}\text{cache/mm}$
→ 得出 TAG 字段为 $17$ 位  
所以地址格式为 $T - L - W = 17 - L - W$

**WORD：**  
$2^2 \text{word/line} \rightarrow \text{WORD} = 2$
地址格式变为 $T - L - W = 17 - L - 2$

**LINE：**  
$\frac{2^{10} \text{byte}}{2^5\text{byte/line}} = 2^5 \text{line}$
→ LINE 字段为 $5$ 位  ****
最终地址格式为 $T - L - W = 17 - 5 - 2$

**验算：**
$17 + 5 + 2 = 24$ ✅

#### Q 3
主存单元地址 $2\text{F}\text{B}165$ 的 T、L、W 字段分别是什么？请用二进制表示。
$T-L-W = 17-5-2$
##### A:
将每个十六进制位转换为 4 位二进制：

| **Hex** | **2** | **F** | **B** | **1** | **6** | **5** |
| :-----: | :---: | :---: | :---: | :---: | :---: | :---: |
| **Bin** | 0010  | 1111  | 1011  | 0001  | 0110  | 0101  |

合并后得到完整的 24 位二进制地址：  
$001011111011000101100101$

根据字段大小进行划分（17 位 T，5 位 L，2 位 W）：
- **TAG（T）**：00101111101100010  
- **LINE（L）**：11001  
- **WORD（W）**：01

#### Q 4
**A：**
TAG、LINE 和 WORD 字段分别占多少位？
内存参数：
- 每个单元是 1 个 word（1 word/cell）；
- 地址总长为 20 位；
- 主存总容量为 16 MB。
缓存参数：
- 直接映射（direct mapped）；
- 每行 8 个 word；
- 缓存总容量为 8 KB。
**B：**  
请用二进制作答并写出完整计算过程。  
主存单元地址 $84\text{C}0\text{D}$ 的 T、L、W 字段分别是多少？
##### A ：
**A：**

|           **TAG**            |         **LINE**         |        **WORD**         |           **总地址**           |
| :--------------------------: | :----------------------: | :---------------------: | :-------------------------: |
| $\log_{2}{\frac{2}{2^{24}}}$ | $\log_{2}{\frac{行}{缓存}}$ | $\log_{2}{\frac{字}{行}}$ | $\log_{2}{\frac{内存}{内存/字}}$ |

**B：** 

## 组相联映射 (Set-Associatie)
![[Pasted image 20241208181458.png]] 
- 将 Cache 块分为若干组, 每个主存块可放到特定分组中的任意位置, 相当于将前两个组合一下
	- $组号 = 主存块号 \space \% \space 分组数$
- 例如, 图中 Cache 共 8 个块, 可以分为 4 组, 则
	- 主存块 4 可以分到第 $4 \space \% \space 4 = 0$ 组的任意位置
	- 主存块 15 可以分到第 $15 \space \% \space 4 = 3$ 组的任意位置
- **直接映射相当于每组只有一行的组相联映射**