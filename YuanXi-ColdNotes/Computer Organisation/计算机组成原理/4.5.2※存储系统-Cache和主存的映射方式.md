由于 Cache 保存的是主存某些数据块的副本, 因此 Cache 和主存会存在一定映射关系
$$
\begin{align}
 & 杂鱼 \heartsuit 杂鱼杂鱼 \heartsuit \textasciitilde \textasciitilde  \\
 & 小 \space Cache \space 的小映射在我的大主存面前真的是杂鱼呢 \heartsuit \\
 & 才映射这么点就不行了嘛 \heartsuit \heartsuit \\
 & 人家还没能满足呢 \space zako \space \heartsuit  \\
 & 在人家喊停之前要狠狠地映射满人家哦 \heartsuit
\end{align}
$$
## 类别
- 全相联映射
	![[Pasted image 20241208181136.png]]
	- 主存块可以放在 Cache 的任意位置中
- 直接映射
	![[Pasted image 20241208181224.png]]
	- 每个主存块只能放到一个特定的位置
		- $Cache \space 块号 = 主存块号 \space \% \space Cache \space 总块数$
	- 例如图 b 中, Cache 共 8 个块
		- 则主存块 1 可以存在 Cache 的 $1 \space \% \space 8 = 1$ 块中
		- 主存块 10 可以存在 Cache 的 $10 \space \% \space 8 = 2$ 块中
- 组相联映射
	![[Pasted image 20241208181458.png]]
	- 将 Cache 块分为若干组, 每个主存块可放到特定分组中的任意位置, 相当于将前两个组合一下
		- $组号 = 主存块号 \space \% \space 分组数$
	- 例如, 图中 Cache 共 8 个块, 可以分为 4 组, 则
		- 主存块 4 可以分到第 $4 \space \% \space 4 = 0$ 组的任意位置
		- 主存块 15 可以分到第 $15 \space \% \space 4 = 3$ 组的任意位置
## 映射的地址
为了知道 Cache 块中映射的是主存的哪个块, 可以给每个 Cache 块增加一个标记
- 在二进制中, 只有 $0$ 与 $1$ 两种状态, 但是初始化时都会变成 $0$. 为了避免所有无效 Cache 块的初始化值 $0$ 被误认为是在映射主存中的 $0$ 号块, 应在标记前加一个有效位
	- 规定有效位为 $1$ 时, 该地址才有效
![[Pasted image 20241208182837.png]]
在本图中, 可以可看出 $0,1,2,7$ 号 Cache 块有映射, 对应的分别是主存的 $9,8,5,0$ 号块
## 全相联映射
假设某个计算机的主存地址空间大小为 $256MB$, 按字节编址, 其数据 Cache 有 8 个 Cache 行, 行长为 $64B$, 则
-  地址空间 $256MB= 2^{28}B$, 表示主存地址为 28 位
- $8$ 个 Cache 行, 行长 $64B$, 则 Cache 大小为 $8 \times 64 = 512B$
- Cache 行即 Cache 块, 与主存大小相等, 因此是以 $64B = 2^6B$ 为一块, 块内地址为 $6$ 位
- 所以主存块号为 $\frac{2^{28}}{2^{6}}=2^{22}, 22$ 位
则每个主存块的地址范围为
![[Pasted image 20241208194536.png]]
首先初始化 Cache 的有效位为 0
![[Pasted image 20241208194635.png]]
假设要把主存的第 $0$ 块放在 Cache 中, 由于是全相联映射, 所以随意放. 假设放到 Cache 的块 $3$
则此时块 3 的有效位变为 1, 标记变为主存块 $0$ 的块号
![[Pasted image 20241208194739.png]]
接着放主存的第 $2^{22}-3$ 块, 假设放到 Cache 块 1, 则同理
![[Pasted image 20241208194923.png]]
### CPU 访问主存地址
例如, 访问主存地址 $\textcolor{#4eadea }{1\dots1101}001110$
1. 取主存地址的前 22 位, 对比 Cache 所有块的标记
2. 若标记匹配且有效位为 $1$, 则 Cache 命中, 访问块内地址为 $001110$ 的单元
3. 若未命中或有效位为 $0$, 则正常访问主存
## 直接映射
$主存块号 \space \% \space Cache \space 总块数$
1. 假设将主存第 0 块放入 Cache 中, 则 $0 \% 8 = 0$, 放在 Cache 块第 0 块, 有效位变为 1, 标记变为主存块号
![[Pasted image 20241208195417.png]]
2. 此时要放主存块 8, 则 $8\%8=0$, 仍然是 Cache 第 0 块, 此时需要覆盖掉原本的内容, 并修改标记为新的块号
![[Pasted image 20241208195726.png]] 
相比于 22 位的标记, 在计算机内部还可以进行优化
- 若 Cache 总块数为 $2^n$, 则主存块号末尾 $n$ 位直接反映它在 Cache 中的位置
	- 因为取余就是除, 二进制除就是左移, 左移 $n$ 位相当于在数后面添加 $n$ 个 0
	- 查看末尾 $n$ 位数, 相当于整除的时候这 $n$ 位为 0, 取余的时候这 $n$ 位就是余数
- 同样, 由于主存块末尾 $n$ 位直接与 Cache 块号对应, 因此存储标记的时候也不需要存储末尾 $n$ 位, 只需要存储 $块号-后n位$ 数字即可
![[Pasted image 20241208200425.png]]
### CPU 访问主存地址
![[Pasted image 20241208200540.png]]
1. 根据主存块号的后 $n$ 位确定 Cache 块号
2. 若主存块号去掉后 $n$ 位后与 Cache 标记匹配且有效位为 1, 则命中, 访问 Cache 内对应单元
3. 若未命中或有效位为 0, 则正常访问主存
## 组相联映射
$主存块号 \space \% \space Cache \space 分组数$
1. 类似地, 假设 Cache 分为 $n$ 组, 则只需要将要复制的主存块复制到主存块号末尾 $n$ 位的组中任意位置即可. 如果组中有空位置, 则不覆盖有内容的位置
2. 然后将对应块的有效位设为 1, 标记设为主存块号去掉末尾 $n$ 位的数字
![[Pasted image 20241208200958.png]]
### CPU 访问主存地址
![[Pasted image 20241208201342.png]]
与前面类似