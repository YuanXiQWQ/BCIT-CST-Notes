由于 Cache 保存的是主存某些数据块的副本, 因此 Cache 和主存会存在一定映射关系
$$
\begin{align}
 & 杂鱼 \heartsuit 杂鱼杂鱼 \heartsuit \textasciitilde \textasciitilde  \\
 & 小 \space Cache \space 的小映射在我的大主存面前真的是杂鱼呢 \heartsuit \\
 & 才映射这么点就不行了嘛 \heartsuit \heartsuit \\
 & 人家还没能满足呢 \space zako \space \heartsuit  \\
 & 在人家喊停之前要狠狠地映射满人家哦 \heartsuit
\end{align}
$$
## 类别
- 全相联映射
	![[Pasted image 20241208181136.png]]
	- 主存块可以放在 Cache 的任意位置中
- 直接映射
	![[Pasted image 20241208181224.png]]
	- 每个主存快只能放到一个特定的位置
		- $Cache \space 块号 = 主存块号 \space \% \space Cache \space 总块数$
	- 例如图 b 中, Cache 共 8 个块
		- 则主存块 1 可以存在 Cache 的 $1 \space \% \space 8 = 1$ 块中
		- 主存块 10 可以存在 Cache 的 $10 \space \% \space 8 = 2$ 块中
- 组相联映射
	![[Pasted image 20241208181458.png]]
	- 将 Cache 块分为若干组, 每个主存块可放到特定分组中的任意位置, 相当于将前两个组合一下
		- $组号 = 主存块号 \space \% \space 分组数$
	- 例如, 图中 Cache 共 8 个块, 可以分为 4 组, 则
		- 主存块 4 可以分到第 $4 \space \% \space 4 = 0$ 组的任意位置
		- 主存块 15 可以分到第 $15 \space \% \space 4 = 3$ 组的任意位置
## 映射的地址
为了知道 Cache 块中映射的是主存的哪个块, 可以给每个 Cache 块增加一个标记
- 在二进制中, 只有 $0$ 与 $1$ 两种状态, 但是初始化时都会变成 $0$. 为了避免所有无效 Cache 块的初始化值 $0$ 被误认为是在映射主存中的 $0$ 号块, 应在标记前加一个有效位
	- 规定有效位为 $1$ 时, 该地址才有效
![[Pasted image 20241208182837.png]]
在本图中, 可以可看出 $0,1,2,7$ 号 Cache 块有映射, 对应的分别是主存的 $9,8,5,0$ 号块
## 全相联映射
假设某个计算机的主存地址空间大小为 $256MB$, 按字节编址, 其数据 Cache 有 8 个 Cache 行, 行长为 $64B$, 则
-  地址空间 $256MB= 2^{28}B$, 表示主存地址为 28 位
- $8$ 个 Cache 行, 行长 $64B$, 则 Cache 大小为 $8 \times 64 = 512B$
- Cache 行即 Cache 块, 与主存大小相等, 因此是以 $64B = 2^6B$ 为一块, 块内地址为 $6$ 位
- 所以主存块号为 $\frac{2^{28}}{2^{6}}=2^{22}, 22$ 位
则每个主存块的地址范围为
![[Pasted image 20241208194536.png]]
首先初始化 Cache 的有效位为 0
![[Pasted image 20241208194635.png]]
假设要把主存的第 $0$ 块放在 Cache 中, 由于是全相联映射, 所以随意放. 假设放到 Cache 的块 $3$
则此时块 3 的有效位变为 1, 标记变为主存块 $0$ 的块号
![[Pasted image 20241208194739.png]]
接着放主存的第 $2^{22}-3$ 块, 假设放到 Cache 块 1, 则同理
![[Pasted image 20241208194923.png]]