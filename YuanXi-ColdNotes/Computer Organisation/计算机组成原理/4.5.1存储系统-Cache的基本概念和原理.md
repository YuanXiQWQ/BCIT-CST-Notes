对于主存, 可以通过双端口 RAM, 多模块存储器提高存储器的工作速度. 然而, 无论怎么优化, 速度差距仍与 CPU 差距很大
- **解决**: 设计更高速的存储单元设计, 例如将 DRAM 改为 SRAM
	- 问题: 存储器价格会上升, 容量也会下降
		- 问题的解决: 基于计算机层次原理, 增加 Cache 层, 缓和 CPU 与主存的速度差
## 原理
### 如果没有 Cache
![[Pasted image 20241208161604.png]]
- 当打开微信进行视频聊天时, 计算机从辅存中将微信数据转移到内存, 然后 CPU 一条一条执行内存中微信的视频聊天功能的指令
	- 但是由于主存的速度跟不上内存速度, 势必会让视频聊天的执行速度很慢, 体验不佳
### 增设 Cache 层级
![[Pasted image 20241208161940.png]]
- 由于在执行微信视频聊天指令时, 大概率此时大部分指令都来自微信视频聊天
- 因此, 可以增设 Cache 层级, 将视频聊天指令单独复制一份进去, 从而配合 CPU 执行速度, 让视频聊天功能执行更快
在现代计算机中, Cache 被集成在 CPU 内部, 用 SRAM 实现, 速度快, 成本高, 集成度低
- 由于 CPU 空间本身有限, 在低集成度下 Cache 无法做得很大, 因此其存储空间注定无法做得太大
## 程序的局部性原理
在前例中, 微信的视频聊天功能可能是一种理想情况, 但是在某一时间内, CPU 是否只会访问某一部分的数据?
以下列代码为例
```c
int sumArrayRows(int a[m][n]){
	int i, j, sum = 0;
	for (i = 0; i < m; i ++) {
		for (j = 0; j < m; j ++){
			sum += a[i][j];
		}
	}
	return sum;
}
```
则该指令在内存空间的存储可以用下图表示
![[Pasted image 20241208162649.png]]
- 在 C 语言中, m 行 n 列的二维数组是一行一行在内存中存储的, 在内存中会展开为一个一维结构
	- 内存中多数地址间相差 4 字节, 因为 C 语言中的 int 类型占 4 字节
- 不难看出, 如果一个数据 A 被访问, 那么与之相邻的数据大概率接下来也会被访问; 不仅数组是按照顺序存放的, 指令也是, 因此当访问指令 B 时, 与之相邻的指令大概率接下来也会被访问
- 
### 性质
- **空间局部性**: 在最近的未来要用到的信息 (指令和数据), 很可能与现在正在使用的信息在存储空间上是临近的
- **时间局部性**: 在最近的未来要用到的信息, 很可能是现在正在使用的信息
基于局部性原理, 不难想到, 可以吧 CPU 目前访问的地址周围的部分数据复制到 Cache 中以方便接下来快速访问
- 对"周围"的界定: 将主存的存储空间"分块", 如, 每 $1 KB$ 为一块. 主存与 Cache 之间**以块级为单位进行数据交换**
- 例如, 当访问 $0 x 114$ 时, 将其所从属的整个分块 $0x000$ 到 $0x400$ 整个 $1 K$ 大小的分块复制到 Cache 中
- 如果一个主存共 $4MB(2^{22}Byte)$, 一个块为 $1KB=2^{10}Byte$, 则整个主存可以被分为 $\frac{2^{22}}{2^{10}}=2^{12}=4096$ 块
- 因此该主存地址前 $12$ 位为块号, 后 10 位为块内地址
![[Pasted image 20241208171140.png]]

如果将程序改为这样
```c
int sumArrayRows(int a[m][n]){
	int i, j, sum = 0;
		for (j = 0; j < m; j ++){
			for (i = 0; i < m; i ++) {
			sum += a[i][j];
		}
	}
	return sum;
}
```
则数据在内存中是一列一列访问, 其空间局部性更差, 相比之下执行会更慢一些
## 性能分析
![[Pasted image 20241208164628.png]]
设 $t_{c}$ 为 CPU 访问一次 Cache 所需时间, $t_{m}$ 是访问一次主存所需时间, 定义命中率 $H$ 表示 CPU 要访问的信息确实在 Cache 中的比率, 则缺失率 (未命中) $M=H-1$
则
方案一: CPU 先访问 Cache, 若未命中则访问主存, 则平均访问时间 $t$ 为
$$
t = Ht_{c} + (1-H)(t_{c}+t_{m})
$$
方案二: 同时访问 Cache 和主存, 若 Cache 命中则立即停止访问主存
$$
t = Ht_{c} + (1-H)t_{m}
$$
### 例题
**假设 Cache 的速度是主存的 5 倍, 且 Cache 的命中率为 $95\%$, 则采用 Cache 后, 存储器性能提高多少? (设 Cache 和主存同时被访问, 若 Cache 命中则终端访问主存)**
$$
\begin{align} \\
 & 设 Cache 的存取周期为 T, 则主存的存取周期为 5T, 平均访问时间为 t \\
 & t=95\% T + (1-95\%)(5T) \\
 & t=95\%T+25\%T \\
 & t=120\%T \\
 & \because 在没有 Cache 的情况下, 访问时间为 5T \\
 & \therefore 性能为原来的 \frac{5T}{1.2T} \approx 4.17倍 \
\end{align}
$$
**假设先访问 Cache, 未命中再访问主存呢?**
$$
\begin{align} \\
 & t = 95\%T + (1-95\%)(T+5T) \\
 & t = 125\%T \\
 & \therefore 性能为原来的 \frac{5T}{1.25T} = 4 倍
\end{align} \\
$$