3.1 存储系统基本概念  
3.2.1 主存储器的基本组成  
3.2.2 SRAM 和 DRAM  
3.5.1 Cache 的基本概念和原理  
3.5.2 Cache 和主存的映射方式  
3.6.1 页式存储器  
3.6.2 虚拟存储器
## 大小端模式
内存中经常存储一些多字节数据, 例如 C 语言中的 int 变量占 4 字节. 其中
- 占用的最左侧的字节称为最高有效字节 (MSB)
- 占用的最右侧的字节称为最低有效字节 (LSB)
在内存中有两种存储多字节的方式, 分别为大端方式和小段方式
### 大端方式
- 将最高有效字节放在内存较低地址, 最低有效字节放在内存较高地址
- 符合人类阅读习惯
### 小端方式
- 将最低有效字节放在内存较低地址, 最高有效字节放在内存较高地址
- 便于机器计算
### 例
对于变量 $x=19088743$ D
- 十六进制形式为 01 | 23 | 45 | 67 H
- 二进制形式为 0000 0001 | 0010 0011 | 0100 0101 | 0110 0111 B
在内存的存储方式可以为

**大端方式:**

|  **内存地址**   | **$0800 H$** | **$0800 H$** | **$0800 H$** | **$0800 H$** |         |
| :-----: | :------: | -------- | -------- | -------- | ------- |
| $\dots$ |  $01 H$  | $23 H$   | $45 H$   | $67 H$   | $\dots$ |

**小端方式:**

|  内存地址   | $0800 H$ | $0800 H$ | $0800 H$ | $0800 H$ |         |
| :-----: | :------: | -------- | -------- | -------- | ------- |
| $\dots$ |  $67 H$  | $45 H$   | $23 H$   | $01 H$   | $\dots$ |

CPU 在对两个 int 型变量进行加法运算时, 从最低有效字节开始加法可以免去一些转移的操作, 因为加法进位是从低位向高位进位的
## 边界对齐
- 现代计算机通常是按字节编址, 即每个字节对应一个地址
- 通常也支持按字, 半字, 字节寻址
- 假设存储字长为 32 位, 则 1 个字=32 bit, 半字=16 bit
- 每次访问只能*读/写* 1 个字
![[Pasted image 20241208034042.png]]
当收到要访问的字地址或字节地址时, 计算对应的字节地址, 可以使用逻辑位移, 即在访问地址的数后面加上对应数量的 $0$
- 二进制的逻辑位移相当于乘 $2$. 位移 $n$ 位就是乘 $2 n$
- 由于一个字有四字节, 一个半字有两字节
	- 因此, 接收字地址时, 可以逻辑位移 2 位得到字节地址
	- 接受半字地址时, 可以逻辑位移 1 位得到字节地址
由于现代计算机是按字节编址, 因此即使支持按字, 半字寻址, 最终也是转换为字节地址
### 特点
由于每次访问只能*读/写* 1 个字, 因此边界对齐方式其实就是牺牲空间利用率换效率, 避免了边界不对齐情况下访问分在两个字的数据时需要查询两次的问题
例如, C 语言中, short 变量占两个字节. 按照图 2.10 和图 2.11 中的两种方式, 设第一个字节地址为 1, 前三个字节已有数据, 则接下来写入 short 变量,
- 边界对齐方式是舍弃地址 4 的字节, 将 short 写入 5,6, 也就是半字 1
- 边界不对齐是将 short 分为两段, 一段写入字节 4, 即半字 1-1, 另一段写入字节 5, 即 1-2
则访问时, 由于边界不对齐方式的 short 跨越了两个字, 因此需要先访问字 1, 再访问字 2, 需要两次访问, 而边界对齐只需要访问一次字 2