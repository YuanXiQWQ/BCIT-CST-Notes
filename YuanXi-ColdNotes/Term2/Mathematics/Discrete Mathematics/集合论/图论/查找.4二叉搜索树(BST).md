使用有序数组保存数据的时候, 如果采用二分法搜索, 可以以 $O(\log_{2}n)$ 的效率查找数据, 但是如果要*插入/删除*数据, 则需要将后面所有数据*后移/前移*, 效率 $O(n)$

- 对于需要经常插入*插入/删除*数据的搜索, 可以使用**二叉搜索树**
## 二叉搜索树 (Binary Search Tree, BST)
### 定义
一棵空树或者具有下列性质的二叉树：
- 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；
- 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；
- 任意节点的左、右子树也分别为二叉查找树；
### 性质
- 以 $O(\log_{2}n)$ 的效率查找, 插入, 删除
- 对于该树中的任意树, 都满足所有**左子树小于根节点**,  所有**右子树大于根节点** (若分别不为空)
- BST 的**中序遍历**一定是**从小到大**排列的, 因为中序遍历是按照左节点, 根节点, 右节点的顺序进行的
## 二叉搜索树的算法
### 查找
- 要查找的数比根节点**大**时, 向根节点**右**节点查找, 反之, **小**时向**左**节点查找
#### 例
对于二叉搜索树 G
![[Pasted image 20241126034704.png]]**查询 5:**
1. 查询 $5 \textcolor{orange}{\lt} 10$, 去<font color="orange">左</font>节点
2. 查询 $5 \textcolor{yellow}{\gt} 4$, 去<font color="yellow">右</font>节点
3. 查询 $5 \textcolor{orange}{\lt} 7$, 去<font color="orange">左</font>节点
4. 查询 $5 \textcolor{green}{=} 5$, 查找<font color="green">成功</font>

---

**查询 23:**
1. 查询 $23 \textcolor{yellow}{\gt} 10$, 去<font color="yellow">右</font>节点
2. 查询 $23 \textcolor{yellow}{\gt} 17$, 去<font color="yellow">右</font>节点
3. 查询 $23 \textcolor{orange}{\lt} 25$, 去<font color="orange">左</font>节点
4. 查询 $23$ <font color="red">没有右节点</font>, 查找<font color="red">失败</font>
### 插入
和查找类似, 要插入数遵循大右小左, 直到对比到树中没有的分支时, 把插入数放到该分支
#### 例
对于二叉搜索树 G
![[Pasted image 20241126034704.png]]
**插入 9**
1. 查询 $9 \textcolor{orange}{\lt} 10$, 去<font color="orange">左</font>节点
2. 查询 $9 \textcolor{yellow}{\gt} 4$, 去<font color="yellow">右</font>节点
3. 查询 $9 \textcolor{yellow}{\gt} 7$, 去<font color="yellow">右</font>节点
4. 7 <font color="green">没有右节点</font>, <font color="green">插入</font> 9
### 构建二叉搜索树
- 依次对每个数进行插入操作
## 删除
#### 删除叶节点
- 直接查找到对应数并删除即可
#### 删除只有*左子树/右子树*的节点
- 查找到对应数后直接使用它的*左子树/右子树*代替它即可
#### 删除既有左子树又有右子树的节点
1. 查找到对应数后删除它
2. 查找到对应数*左子树中最大的节点/右子树中最小的节点*(也就是中序遍历中被删除数的直接*前驱/后继*, 也就是*前/后*节点), 代替掉它原来的位置
3. 用来代替的数相当于原来位置再进行一次删除操作