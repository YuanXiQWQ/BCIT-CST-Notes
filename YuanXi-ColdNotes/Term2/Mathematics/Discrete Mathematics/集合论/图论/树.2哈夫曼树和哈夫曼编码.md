## 二进制编码
- 将字符编码成二进制

对于字符串 $A \space B \space A \space A \space C \space D \space C$, 想办法将其转换成二进制编码, 可以很自然地想到如下的编码方法:

| $A$ | $B$ | $C$  | $D$  |
| :-: | :-: | :--: | :--: |
| $0$ | $1$ | $10$ | $11$ |
则二进制编码为 $0100101110$
- 但是这样编码存在问题: 在解码的时候存在歧义
	- 如 $010$ 在解码的时候无法判断是表示 $ABA$ 还是 $AC$
- 因为含有**字符前缀被另外编码**
## 解决方案
### 等长编码
- 将编码长度固定, 则解码的时候只需要按长度一个个解码即可
- 但是空间利用率太低
### 哈夫曼编码 (Huffman Coding)
- 使用**变长编码表**对源符号进行编码
- 变长编码表是通过一种评估来源符号出现概率的方法得到的，出现概率高的字母使用较短的编码，反之则使用较长的编码
- 这便使编码之后的字符串的平均长度、期望降低，从而达到无损压缩数据的目的
- **带权路径长度**: 每个支节点分别求它们的权值乘以编码长度, 最后相加
#### 解法
1. 对于字符串 $A \space B \space A \space A \space C \space D \space C$, 首先判断各标识出现频率

| **标识** | **频次** |
| :----: | :----: |
|  $A$   |  $3$   |
|  $C$   |  $2$   |
|  $B$   |  $1$   |
|  $D$   |  $1$   |
则 $A$ 使用最短的编码, $B, D$ 使用最长的编码
2. 构造二叉树, 每次合并最小的两个顶点, 左右无所谓, 并生成一个根节点, 权值为两点相加
	2.1 首先权值最小的是 $B, D$, 都是 $1$, 则合并 $B,D$, 其根节点权值为 $1+1=2$
	![[Pasted image 20241126032016.png]]
	2.2 然后合并现在最小的两个点, 为 $C$ 和 $B,D$ 的根节点, 权值都是 2
	![[Pasted image 20241126032139.png]]
	2.3 然后合并现在最小的两个点, 为 $A$ 和根节点, 权值分别为 $3,4$
	![[Pasted image 20241126032239.png]]
	2.4 最终得出该字符编码的哈夫曼树
3. 给二叉树每个节点定义为 $0$ 与 $1$ (一般是左节点为 $0$, 右节点为 $1$), 则字符的编码为其所在哈夫曼树的最短路径上的编码组合
	![[Pasted image 20241126032526.png]]

| $A$ |  $B$  | $C$  |  $D$  |
| :-: | :---: | :--: | :---: |
| $1$ | $010$ | $00$ | $011$ |
这样就避免了前缀占用造成的歧义问题 (二叉树的根节点不能表示字符), 并且尽最大可能缩短了平均编码长度
4. 该哈夫曼编码的带权路径长度为 $13$
$$
2 \times 2 + 1 \times 3 + 1 \times 3 + 3 \times 1 = 13
$$