## 定义
- **机器**: 一个系统, 接收输入, 改变自身的状态, 产生输出, 称为机器
- **有限状态机**: 在逐个接受输入字符的过程中, 机器状态会发生多次改变, 最终会停止在某个状态, 并产生输出. 如果对于所有的输入, 机器状态的数目有限, 称为有限状态机 (Finite State Machine, FSM)

## 有限状态机
是一个五元组. $M(A,S,Y,s_0,F)$.
其中:
- $A$: **输入**字符串的字母表
- $S$: 机器的有限**状态**集合
- $Y \subseteq S$: 被判断为"**接受**"的状态
- $s_0 \in S$ : **初始**状态
- $F : S \times A \rightarrow S$: **状态转移函数**, 指明在某个状态下接受输入字符所引起的状态变迁
### 例:
$A={a,b}$
$S={s_0,s_1,s_2}, Y={s_0,s_1}, s_0为初始状态$
$F如下表$

|   F   |   a   |   b   |
| :---: | :---: | :---: |
| $s_0$ | $s_0$ | $s_1$ |
| $s_1$ | $s_0$ | $s_2$ |
| $s_2$ | $s_2$ | $s_2$ |

- **从状态 $s_0$ 出发**：
    - 输入 $a$ 时，状态保持在 $s_0$
    - 输入 $b$ 时，状态转移到 $s_1$
- **从状态 $s_1$ 出发**：
    - 输入 $a$ 时，状态返回到 $s_0$
    - 输入 $b$ 时，状态转移到 $s_2$
- **从状态 $s_2$ 出发**：
    - 无论输入是 $a$ 还是 $b$，状态都保持在 $s_2$
## 状态图
### 定义
- 状态图 $D=D(M)$ 是边带**标记**的**有向图**
- 节点为状态, 转移函数决定边的走向和标记
- 接受状态用双圈表示
- **边**的定义: 如果 $F(s_j,a)=s_k$, 则从节点 $s_i$ 做标记为 $a$ 的有向边到节点 $s_k$
- 初始状态 $s_0$ 用一个特殊的无源箭头标识
- 例: 赋权有向图
![[Pasted image 20241104160530.png]]
### 机器识别的语言

- M 识别的 A 上的所有字符串
- $w = a_1 a_2 \dots a_m \in A^*$
- $w$ 确定了一个状态序列 $s_0, s_1, s_2, \dots, s_m$
  
  其中 $F(s_{i-1}, a_i) = s_i$
  
- 也就是说，确定了模拟路径 $P = (s_0, a_1, s_1, a_2, s_2, \dots, a_m, s_m)$
- 如果 $s_m \in Y$ 则称 M 识别 $w$
### 例: 从状态图看识别语言
- 从上图的例子中, 查看下列输入是否识别
	- Ababba
		1. $F(s_0,a)=s_0$
		2. $F(s_0,b)=s_1$
		3. $F(s_1,a)=s_0$
		4. $F(s_0,b)=s_1$
		5. $F(s_1,b)=s_2$
		6. $F(s_2,a)=s_2$
		7. 最终结果为不识别 ($s_2$)
	- Baab
		1. $F(s_0,b)=s_1$
		2. $F(s_1,a)=s_0$
		3. $F(s_0,a)=s_0$
		4. $F(s_0,b)=s_1$
		5. 最终结果为识别 ($s_1$)
	- 空串
		1. $s_0$
		2. 最终结果为识别 ($s_0$)
- 总结为, 图例的机器识别所有不包含连续两个 $b$ 的字符串
	- 因为一旦接受一个 $b$, 就会变为 $s_1$ 状态, 此时如果接受一个 $a$ 则回到 $s_0$, 一旦再接受一个 $b$ 就进入 $s_2$,再也出不来了
	- 而如果接受的一直为 $a$, 则一直安全停留在 $s_0$; 即使已经到不接受的边缘状态 $s_1$, 只要再接受一个 $a$ 就会再次回到 $s_0$
### 正则语言和有限状态机
#### Kleene 定理
当且仅当存在一个有限状态机 $M$, 使得字母表 $A$ 上的形式语言 $L=L(M)$ 时, $L$ 是正则的
#### 例
构造自动机 M, 识别恰好以 bb 结尾的字符串
- 正则表达式: $(a|b)*bb$
	-  $(a|b)*$：表示任意数量的字符 a 或 b 的组合, $∗$ 表示可以重复任意次数
    - $bb$：要求字符串以两个连续的 $b$ 结尾。
- FSM:
 ![[Pasted image 20241104162558.png]]
## 泵引理（Pumping Lemma）

- 长度 **超过** 状态数目的接受串 $w$，都可以表示成 $w = xyz$ 形式，而 $xy^n z$ 都会被 $M$ 接受。
- 设 $w$ 对应的状态序列为 $s_0, s_1, s_2, \dots, s_n$
  
  $n$ 大于状态的数目 $|S|$，所以根据鸽笼原理必有 $s_i = s_j$ （$i < j$）

- 令 $x = a_1 a_2 \dots a_i$, $y = a_{i+1} \dots a_j$, $z = a_{j+1} \dots a_n$

- $x y$ 以 $s_j$ 状态结束，$x y z$ 以 $s_n$ 状态结束，所以 $x y^m$ 也以 $s_j$ 状态结束，$x y^m z$ 结尾状态仍为 $s_n$
![[Pasted image 20241104163631.png]]
### 证明： $L = \{a^m b^m : m > 0\}$ 不是正则语言
- $a^mb^m$ 表示前端为 $a$, 后端为 $b$, 且 $a$, $b$ 的总数量相同
- 假设 $L$ 是正则语言，则有有限状态机 $M$ 接受 $L$，假设 $M$ 状态个数为 $k$
- 令 $w = a^k b^k$，则一定有 $|w| > k$，根据泵引理，$w = xyz$，其中 $y$ 非空，而且 $xy^2z$ 也被 $M$ 接受
- 如果 $y$ 仅含有 $a$ 或仅含有 $b$，那么 $xy^2z$ 中 $a, b$ 的个数不相等，应该不属于 $L$
- 如果 $y$ 同时含有 $a$ 和 $b$，那么 $y^2$ 中一定会出现 $a$ 在 $b$ 之后的情况，$xy^2z$ 也应该不属于 $L$
- 因为矛盾说明假设错误，$L$ 不是正则语言
## 机器同余 (Machine Congruence)
是有限自动机（FSM）中一种重要的等价关系，用于描述状态之间的相似性或等价性。机器同余的概念帮助我们理解哪些状态在处理特定输入时表现得“相同”，从而可以简化状态机。
### 定义
对于一个有限状态机 $M$，如果两个状态 $p$ 和 $q$ 对于所有可能的输入字符串表现一致，那么我们称 $p$ 和 $q$ 是**机器同余**的，记作 
$$
p \sim q
$$
具体来说：
如果对于任意输入字符串 $x$，状态 $p$ 和 $q$ 接受 $x$ 后都进入相同的状态或者都有相同的接受性（即都属于接受状态或都不属于接受状态），那么 $p$ 和 $q$ 是机器同余的。即：
$$
p \sim q \quad \Longleftrightarrow \quad \forall x, \, (p.x \text{ 和 } q.x \text{ 都是接受状态，或都不是接受状态})
$$
### 作用
简化状态机。通过合并同余状态，我们可以将原始的状态机简化为一个**等价最小化自动机**，即拥有相同语言识别能力但状态数量最少的状态机
### 机器同余的判定方法
要判断两个状态是否机器同余，可以使用**区分条件**：
1. 首先，检查两个状态是否都属于接受状态或都不属于接受状态。如果不同，则它们不是同余的
2. 然后，递归地查看在任意输入字符作用下，这两个状态转移后的状态是否也满足机器同余条件
## 商机器 (Quotient Machine)