- 对于 DRAM 芯片, 存取时间为 $r$, 那么需要的恢复时间也为 $r$, 而又需要进行刷新, 因此存取周期 $T=4r$
- 双端口 RAM 和多模块存储器解决了下列两个问题
	- 如果多核 CPU 同时访问内存, 当第一个 CPU 访问完后, 第二个 CPU 需要等待恢复时间后才能再次访问
	- 即便是单核 CPU, 读写速度也比主存快很多, 主存的恢复时间太长
## 双口 RAM
![[Pasted image 20241208134812.png]]
- 优化多核 CPU 访问一根内存条的速度
- 需要两组完全独立的数据线, 地址线, 控制线; CPU, RAM 中也要有更复杂的控制电路
### 两个端口对同一主存操作的情况
- 两个端口同时对不同的地址单元存取数据
	- 不冲突
- 两个端口同时对同一地址单元读出数据
	- 不冲突
- 两个端口同时对同一地址单元写入数据
	- 写入错误
- 两个端口同时对同一地址单元分别写入, 读出数据
	- 读出错误
当出现任何冲突时, RAM 的控制电路会发出"忙"的信号 (为 $0$), 由判断逻辑决定暂时关闭一个端口, 未被关闭的端口正常访问, 被关闭的端口延长一段时间后访问
## 多体并行存储器
![[Pasted image 20241208141254.png]]
- 即使对于单核 CPU, 其操作速度仍比主存快很多, 而主存每次读取后又需要一段恢复时间
- 当 CPU 想要连续读取一些数据的时候, 就必须等待恢复时间
- 可以通过串联 $n$ 个模块, 每个模块拥有相同容量和速度, 计算机可以自有地并行或交叉地从不同存储器进行读取操作
	- 相对于单体多字存储器:
		- 单体多字存储器类似于从字节到半字, 字的位扩展, 将字扩展为多个字为一体
		- 比多体并行存储器灵活性更差, 一次读取必须按一行读取, 只对连续内存空间的数据有优化, 不能同时读取多行数据
### 高位交叉编址
当有多个存储体时, 将地址的高位比特位定义为存储体的编址 (图中的 $M_{0},M_{1},M_{2},M_{3}$)
- 例如, 假设每个存储体只有 8 个存储单元, 那么需要 $\log_{2}8=3$ 位地址位, 则地址位给出 $5$ 位, 前两位(高位)用于表示存储体地址
![[Pasted image 20241208141714.png]]
### 低位交叉编址
将地址的低位比特位定义为存储体的编址
- 类似地, 使用后两位 (低位) 表示存储体地址
![[Pasted image 20241208141810.png]]
### 特点
- 两种编址方式会导致存储体地址的十进制分别为
	- 高位交叉编址: $M_{0}:\{0,1,2,3,4,5,6,7\}, M_{1}\{8,9,10,11,12,13,14,15\},\dots$
	- 低位交叉编址: $M_{0}:\{0,4,8,16,32,64,128,256\}, M_{1}\{1,5,17,33,65,129,257\},\dots$
- 可见, 高位交叉编制的地址顺序为自上而下, 从左往右 (按照图例), 低位顺序为从左往右, 自上而下
- 这样的区别会导致, 假设每个存储体存取周期为 $T$, 存取时间为 $r$, $T=4 r$:
	- 在高位交叉编址下, 如果要连续访问 $00000,00001,00010,00011,00100$, 则每次访问都处于同一存储体, 总共访问了五次同一存储体, 则需要等待四次恢复时间, 总耗时为 $5 T$
		![[Pasted image 20241208142552.png]]
	- 在低位交叉编制下, 同样连续访问这五个地址, 无需等待恢复时间,因为虽然 00000 与 00100 在同一存储体下, 但是访问了四个存储体后的时间正好为 $4r=1T$, 此时的 $M_{0}$ 已经准备好下一次读取了, 因此总耗时为 $2T$
		![[Pasted image 20241208143337.png]]
- 因此, 在连续取 $n$ 个存储字时:
	- 使用高位交叉编址时, 耗时为 $nT$
	- 使用低位交叉编址时, 耗时为 $T+(n-1)r$
### 多体交叉存储器应该取几个体
- 宏观上, 一个存储周期内, $m$ 体交叉存储器可以提供的数据量为单个模块的 $m$ 倍
- 设存取周期为 $T$, 存取时间为 $r$, 为了使流水线不间断, 应保证模块术 $m \geq \frac{T}{r}$
	- 因为如果 $m \lt \frac{T}{r}$, 例如只有 $3$ 个存储体
	  ![[Pasted image 20241208143717.png]]
		- 经过 $3r$ 后, CPU 重新回到 $M_{0}$ 存储体, 而此时 $M_{0}$ 还没有恢复, 因此 CPU 必须再等待 $r$ 后才能再次存取, 因此不能完全发挥该模式的作用
	- 如果 $m \gt \frac{T}{r}$, 当 CPU 访问 $M_{3}$ 时, $M_{0}$ 已经准备好再次被访问, 但是 CPU 却要先访问 $M_{4}$, 导致此时 $M_{0}$ 闲置, 因此尽管已经发挥该模式的作用, 但是由于存储体成本较高, 该模式也不是最佳方案
		![[Pasted image 20241208144057.png]]
- 因此最佳方案是 $m = \frac{T}{r}$