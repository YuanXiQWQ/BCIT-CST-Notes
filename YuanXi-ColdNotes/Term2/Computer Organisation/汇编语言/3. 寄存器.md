参考：[汇编 寄存器 | 汇编语言教程](https://www.w3ccoo.com/assembly/assembly_registers.html)
# 处理器寄存器
CPU 从存储器中访问数据并处理它们。然而，内存的速度远低于 CPU 的速度。为了加速操作，CPU 包含一些内部存储器存储位置，称为寄存器。x86 架构中有 10 个 32 为和 6 个 16 为处理器寄存器。

寄存器分为三大类：
- **通用寄存器**
- **控制寄存器**
- **段寄存器**

而通用寄存器进一步分为：
- **数据寄存器**
- **指针寄存器**
- **索引寄存器**
## 通用寄存器
### 数据寄存器
四个 32 位数据寄存器用于算术、逻辑运算和其它运算。这些寄存器可以通过三种方式使用：
- 作为完整的 32 位数据寄存器：EAX、EBX、ECX、EDX（在 64 位中，还有 R 开头的 RAX 等，扩展方式同 32 位对于 16 位的方式）
- 32 位寄存器的低位可用作四个 16 位数据寄存器：AX、BX、CX、DX
- 16 位寄存器又可分为对应的高低位（如 AX $\rightarrow$ AH、AL）
![[Pasted image 20250713054103.png]]
其中一些数据寄存器在算术运算中具有特定用途：
- **AX** 是**主累加器**：用于输入/输出和大多数算术指令
	- 例如，在乘法运算中，根据操作数的大小将一个操作数存储在 EAX 或 AX 或 AL 寄存器中。
- **BX** 被称作**基址寄存器**，因为它可以用于索引寻址
- **CX** 被称为**计数寄存器**，与 ECX 一样，CX 寄存器存储迭代操作中的循环计数
- **DX** 被称作**数据寄存器**，可以用于输入/输出操作；还与 AX 和 DX 一起使用，用于涉及大值的乘除法运算
### 指针寄存器
指针寄存器是 32 位 EIP、ESP 和 EBP 寄存器以及低位相应的 16 位 IP、SP 和 BP。
![[Pasted image 20250713055151.png]]
指针寄存器分为三大类：
- **指令指针（IP）**：16 为 IP 寄存器存储吓一跳要执行的指令的偏移地址。IP 与 CS 关联给出了代码段中当前指令的逻辑地址（CS: IP）。
- **堆栈指针（SP）**：16 为 SP 寄存器提供程序堆栈内的偏移值。SP 与 SS 寄存器相关（SS: SP），指的是程序堆栈中数据或地址的当前位置。
- **基址指针（BP）**：16 位 BP 寄存器主要帮助引用传递给子程序的参数变量。（SS: SP）得到参数的位置。还可以用（DI: BP）、（SI: DP）进行特殊寻址。
### 索引寄存器
索引寄存器是 32 位的 ESI 和 EDI 寄存器，以及它们低位对应的 16 位寄存器 SI 和 DI，主要用于地址运算和字符串处理指令中。
![[Pasted image 20250713055605.png]]
索引寄存器分为两大类：
- **源索引（SI）**：用于表示源数据在内存中的偏移地址，常用于字符串操作中的**读取位置**。例如，`movsb` 指令会从 `DS:SI` 指向的位置复制一个字节。
- **目标索引（DI）**：用于表示目标数据在内存中的偏移地址，常用于字符串操作中的**写入位置**。例如，`movsb` 会把数据复制到 `ES:DI` 指向的地址中。
## 控制寄存器
控制寄存器是 32 为的指令指针寄存器和 32 为标志寄存器的组合。

许多指令涉及比较和数学计算，并更改标志的状态，而其它一些条件指令会测试这些状态标志的值，以将控制流带到其它位置。

常见的标志位有：
- **溢出标志（OF）**：表示有符号算术运算后数据的高位溢出。
- **方向标志（DF）**：确定或比较字符串数据的左右方向。
	- DF 为 0 时，字符串采取从左到右的方向，1 时相反。
- **中断标志（IF）**：决定是否忽略或处理键盘输入等外部中断。
	- IF 为 0 时禁用外部中断，1 时相反。
- **陷阱标志（TF）**：允许将处理器的操作设置为单步模式。
	- DEBUG 程序设置了陷阱标志，因此可以一次单步执行一条指令。
- **符号标志（SF）**：显示算术运算结果的符号，根据算术运算后数据项的符号来设置，符号由高位表示。
	- 正时设置 SF 为 0 ，负时为 1.
- **零标志（ZF）**：表示算术或比较运算的结果。
	- 非零时设置 ZF 为 0，否则为 1。
- **辅助进位标志（AF）**：包含算术运算后从位 3 到位 4 的进位，用于专门的算术。
	- 当 1 字节算术运算导致从位 3 进位到位 4 时，AF 被置位。
- **奇偶校验标志（PF）**：用于设定奇偶校验。
	- PF 为 0 时是偶校验，1 时为奇校验。
- **进位标志（CF）**：包含算术运算后从高位进位 0 或 1，还用于存储 shift 或 rotate 操作的最后一位的内容。

下表表示16位Flags寄存器中标志位的位置:

| **标志** |     |     |     |     | OF  | DF  | IF  | TF  |
| :----: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
| **位**  | 15  | 14  | 13  | 12  | 11  | 10  |  9  |  8  |
| **标志** | SF  | ZF  |     | AF  |     | PF  |     | CF  |
| **位**  |  7  |  6  |  5  |  4  |  3  |  2  |  1  |  0  |

## 段寄存器
除了 DS（数据段）、CS（代码段）、SS（堆栈段） 寄存器外，还有其它额外段寄存器，提供额外的段来存储数据：
- ES - 附加段（Extra Segment）
- FS - 自定义段（F Segment），从 E 首字母的顺延
- GS - 自定义段（G Segment），从 F 首字母的顺延

段寄存器存储段的起始位置。段从 16 的整数倍的地址开始，也就意味着在 16 进制中，段地址的末位一定是 0，因此这个 0 通常不存储在段寄存器中。

为了获得段内数据的物理地址，还需要偏移值。处理器将段地址和偏移值组合起来获得物理地址。

## 寄存器使用示例
```NASM
section .text
global _start     ; 必须声明，用于链接器（如 gcc）

_start:           ; 指定程序入口点

	mov edx, len  ; 将消息长度（len）放入 edx
    mov ecx, msg  ; 将消息字符串地址放入 ecx
    mov ebx, 1    ; 文件描述符 1（标准输出 stdout）
    mov eax, 4    ; 系统调用号 4（sys_write）
    int 0x80      ; 调用内核，执行写操作（打印 msg）

    mov edx, 9    ; 设置接下来要写的长度为 9
    mov ecx, s2   ; 将第二个消息（9 个星号）地址放入 ecx
    mov ebx, 1    ; 文件描述符 1（标准输出 stdout）
    mov eax, 4    ; 系统调用号 4（sys_write）
    int 0x80      ; 调用内核，打印星号行

    mov eax, 1    ; 系统调用号 1（sys_exit）
    int 0x80      ; 调用内核，退出程序

section .data
msg db '显示九个星号', 0xa   ; 一条消息字符串，0xa 是换行符（\n）
len equ $ - msg                    ; 计算 msg 的长度（从 msg 到当前位置）

s2 times 9 db '*'                  ; 定义一个由 9 个星号组成的字符串
```
输出
```
显示九个星号
*********
```