## 树（Tree）
### 定义
- **树**是一个极小的无圈连通图，去掉任意一条边都不再连通
- **根树（Rooted Tree）**：指定一个根节点的树。
- **二叉树（Binary Tree）**：每个节点的子节点不超过两个。
### 性质
- 如果一个图是树，则满足以下等价条件：
	- 图中有 $n$ 个顶点，且恰好有 $n-1$ 条边；
	- 任意两个顶点之间有且仅有一条简单路径；
	- 添加任意一条边都会产生环；
	- 删除任意一条边，图不再连通。
- 设 $G$ 是 $n$ 阶 $m$ 条边的树, 则 $m=n-1$
- 任意阶数大于 $1$ 的树中至少包含 $2$ 个度数为 $1$ 的点

## 生成树（Spanning Tree）
## 定义
- 无向图 $G$ 的生成树是具有 $G$ 的全部顶点，但边数最少的连通子图
- 一个图的生成树可能有多个

### 广度优先搜索算法（Breadth-first search，BFS）
- 广度优先搜索算法（英语：Breadth-first search，缩写：BFS），又译作宽度优先搜索，或横向优先搜索，是一种图形搜索算法。简单的说，BFS 是从根节点开始，沿着树的宽度遍历树的节点。如果所有节点均被访问，则算法中止
#### 算法 (边的权值相等时)
- 系统性地展开并检查图中的所有节点
	1.  访问根节点
	2. 访问距离根节点的路径为 1 的顶点 (先后顺序不重要)
	3. 访问距离根节点的路径为 2 的顶点 (先后顺序不重要)
	4. ...
	5. 直到将所有节点访问完毕
- 因此, 当访问到要求顶点的同时, 也找到了根节点到该节点的最短路径
![[Pasted image 20241119065534.png]]
- 节点一旦被访问, 该节点的相邻节点即加入到队列末尾
#### 从邻接矩阵找到相邻顶点
对于矩阵
$$
\begin{array}{c|cccccc}
   & 1 & 2 & 3 & 4 & 5 & 6 \\ \hline
1 & 2 & 1 & 0 & 0 & 1 & 0 \\
2 & 1 & 0 & 1 & 0 & 1 & 0 \\
3 & 0 & 1 & 0 & 1 & 0 & 0 \\
4 & 0 & 0 & 1 & 0 & 1 & 1 \\
5 & 1 & 1 & 0 & 1 & 0 & 0 \\
6 & 0 & 0 & 0 & 1 & 0 & 0
\end{array}
$$
1. 首先从顶点 $1$ 开始 (第一行), 其中非零列为 1,2,5, 则去除 1 本身, 该顶点的相邻顶点是 2,5
	- 队列: 1,2,5
2. 再从顶点 2 开始 (第二行), 非零为 1,3,5, 则相邻顶点为 1,3,5, 去除访问过的 1, 为 3,5
	- 队列: 1,2,5,3
3. 再从顶点 5 开始 (第五行), 非零为 1,2,4
	- 队列: 1,2,5,3,4
4. 顶点 4 , 非零为 3,5,6
	- 队列: 1,2,5,3,4,6 
5. 结束

### 深度优先搜索算法（Depth-First-Search，DFS）
- 深度优先搜索算法（英语：Depth-First-Search，缩写为 DFS）是一种用于遍历或搜索树或图的算法。这个算法会尽可能深地搜索树的分支。当节点 v 的所在边都己被探寻过，搜索将回溯到发现节点 v 的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。这种算法不会根据图的结构等信息调整执行策略
#### 算法
以下图为例:
![[Pasted image 20241119071823.png]]
1. 访问根节点
2. 访问根节点的下一个顶点 ,可以是 1,2, 随机选一个 1
3. 访问顶点 1 的下一个顶点, 可以是 ~~0~~,2,3,4, 由于 0 已经访问过, 所以随机访问 2
4. 访问 2 的下一个顶点, 可以是 ~~0,1~~, 由于都已经访问过, 所以回退一步, 从 1 的邻点 ~~0,2~~,3,4 访问 3
5. 3 邻点 ~~1~~,5, 访问 5
6. 5 邻点 ~~3~~, 6,7,8, 访问 6
7. 6 邻点 ~~5~~, 回退, 5 邻点 ~~3,6~~,7,8, 访问 7
8. 7 邻点 ~~5~~,8, 访问 8
9. 8 邻点 ~~5,7~~,9, 访问 9
10. 9 邻点 ~~8~~, 回退
11. 8 邻点 ~~5,7,9~~, 回退
12. 7 邻点 ~~5,8~~, 回退
13. 5 邻点 ~~3,6,7,8~~, 回退
14. 3 邻点 ~~1,5~~, 回退
15. 1 邻点 ~~0,2,3~~,4, 访问 4
16. 4 邻点 ~~1~~, 回退
17. 1 邻点 ~~0,2,3,4~~, 回退
18. 回到根节点, 完成遍历