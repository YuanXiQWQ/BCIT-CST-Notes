## 归并操作
- 假设有两个有序数组 `a[5]`, `b[4]` 则对两个数组的有序合并即归并操作
- 每次归并都选择两个数组中最小的进行比较
![[Pasted image 20241126065915.png]]
1. 开创一个长度至少为 a, b 长度总和的数组 `c[5 + 4]`
2. 比较 `a[0],b[0]`, `a[0]` 的 `12` 最小, 放在第一位; 此时 `a[]` 中最小的就变成了 `a[1]`
3. 继续比较两个数组中最小的值: `a[1],b[0]`, 结果是 `a[1]` 的 `14` 最小, 放在第二位, `a[]` 的最小值变成了 `a[2]`
4. 继续比较两最小值, 此时为 `b[0]`, 放在第三位, 此时 `b[]` 的最小值变成 `b[1]`
5. 以此类推, 直到合并完两个数组. 当其中一个数组全清空时, 另一个数组直接将剩下的直接放在最后就行了
## 归并排序
- **原理**: 每轮都对相邻子序列两两归并
- **步骤**
	1. 将每个元素拆分成独立的子序列, 则由于每个序列都只有一个元素, 此时每个序列都是有序的, 符合归并操作的前提 (两个有序数组)
	2. 对相邻的两个子序列进行归并
		1. 开一个临时数组 `k[2]`, 用来保存合并后的结果
		2. 归并: 小的放前面, 大的放后面
		3. 用 `k[2]` 覆盖掉原来的那两个数组
	3. 重复步骤 2, 直到归并完全部的子序列
	4. 假设第一轮共拆分出 $2n$ 或 $2n+1$ 组子序列, 则一轮过后会归并为 $n$ 组子序列
	5. 开始第二轮, 对相邻的两个子序列进行归并
		1. 开一个临时数组 `k[4]`, 用来保存合并后的结果
		2. 归并: 小的放前面, 大的放后面
		3. 用 `k[4]` 覆盖掉原来的那两个数组
	6. 重复步骤 5, 知道归并完全部的子序列
	7. 此时还有 $\frac{n}{2}$ 组子序列
	8. 以此类推 
- 特点:
	- 排序轮数: $O(\log_{2}n)$
	- 每一轮的归并操作: $O(n)$
	- 时间复杂度:$O(n\log_{2}n)$
	- 辅助空间: $O(n)$