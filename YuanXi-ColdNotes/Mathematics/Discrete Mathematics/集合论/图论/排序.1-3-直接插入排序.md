对于无序数组 A

| **索引** | 0  | 1  | 2  | 3  | 4  | 5  | 6  | 7  | 8  | 9  | 10 |
|----------|----|----|----|----|----|----|----|----|----|----|----|
| **值**   | 36 | 27 | 20 | 60 | 55 | 7  | 71 | 36 | 44 | 67 | 16 |
- 最开始的有序区只包含 `A[0]`, 因为只有它一个元素, 必然有序
## 直接插入排序
- 对于数组 `A[11]`, 直接插入排序的操作方法为
	1. 将数组首位 (`A[0]`) 定为初始有序区
	2. 创建一个临时变量, 并赋值为有序区后面的第一个元素作为待检元素, 以防插入元素时的元素位移造成待检元素丢失
	3. 从后往前依次与有序区元素进行比较, 元素的插入伴随着有序区的扩大 (即待检元素前的元素整体后移)
		- 如果遇到比自己大的元素, 则插入到该元素前面, 否则插入到后面
		- 如果被插入到了前面, 需要再与有序区更前方的元素比较, 以此类推, 直到遇到比自己小或相等的元素
- **时间效率**: 
	- 在最理想的情况, 即元素本身已经排列好, 则对于 $n$ 个元素:
		- 比较次数: $n-1$
		- 移动次数: $0$
		- 时间复杂度: $O(n)$
	- 最坏的情况, 即元素完全逆序排列, 则对于 $n$ 个元素:
		- 比较次数: $\sum^{n-1}_{i=1}i = \frac{n(n-1)}{2}$
		- 移动次数: $(n - 1) \times 2 + \sum^{n-1}_{i=1}i=\frac{(n+4)(n-1)}{2}$
		- 时间复杂度: $O(n^2)$
	- 平均时间复杂度: $O(n^2)$
	- 辅助空间: $O(1)$
## 折半插入排序
- 与直接插入类似, 也是从第二个数开始, 依次将每个数插入到前面的有序区
- 不同点在于, 在有序区寻找插入位置时, 使用折半查找法 (二分法)
	1. 创建 `left` 和 `right`, 以及 `mid = (left + right) / 2` 指向有序区的首位和中间 (不为整数向下取整)
	2. `temp` 与 `mid` 的数比较, 小于就让 `right = left - 1`, 大于等于就让 `left + mid + 1`
	3. 直到 `left` 大于 `left` 时停止, 此时 left (等同于 right + 1) 的位置就是插入位置
### 例
有序区后第一位 $28$ 与有序区最后一位 $60$ 比较, $28 \lt 60$, 因此需要在有序区寻找位置
	![[Pasted image 20241126054720.png]]
 1. 将 $28$ 赋值到 `temp`
	![[Pasted image 20241126054831.png]]
 2. 设变量 `left`, `right` (或者 `low`, `high`) 分别指向索引 ` 0 ` 和 ` 5 `
	![[Pasted image 20241126055002.png]]
3. 确定中间位 `mid = (left + right) / 2` 为 2.5, 向下取整指向索引 `2`
	![[Pasted image 20241126055210.png]]
4. 用 `temp` 与求得的中间值 `A[2]` 进行对比, $28 \gt 27$, 应当插入在 `mid` 的右侧, 因此缩小范围, 将 `left` 指向 `mid + 1`
	![[Pasted image 20241126055348.png]]
5. 同理, 求得新的 `mid`, 然后再次对比, 此时 $28 \lt 55$, 应当插入在 `mid` 的左侧, 因此缩小范围, 将 `right` 指向 `mid - 1`
	![[Pasted image 20241126055430.png]]
6. 再次求出 `mid` , 然后再次对比, 此时 $28 \lt 36$, 应当插入在 mid 的左侧, 因此缩小范围, 将 `right` 指向 `mid - 1`
	![[Pasted image 20241126055817.png]]
7. 更新后的 `right` 大于 `left`, 对比终止
	![[Pasted image 20241126060039.png]]
8. 先将该位置和它后面的元素后移, 然后将 `temp` 插入到当前位置
	![[Pasted image 20241126060152.png]]
	- **时间效率**: 
	- 在最理想的情况:  $O(n)$
	- 最坏的情况:  $O(n^2)$
	- 平均时间复杂度: $O(n^2)$
	- 辅助空间: $O(1)$