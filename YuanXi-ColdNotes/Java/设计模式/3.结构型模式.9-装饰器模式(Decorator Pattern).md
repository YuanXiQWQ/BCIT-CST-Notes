## 总结
### 概述
装饰器模式通过包装对象来扩展其功能，避免了子类的膨胀，提供了更灵活的对象组合方式
### 实现
```java
// 组件接口
public interface Coffee {
    double getCost();
    String getDescription();
}

// 具体组件
public class SimpleCoffee implements Coffee {
    public double getCost() {
        return 2.0;
    }

    public String getDescription() {
        return "Simple Coffee";
    }
}

// 抽象装饰器
public abstract class CoffeeDecorator implements Coffee {
    protected Coffee decoratedCoffee;

    public CoffeeDecorator(Coffee coffee) {
        this.decoratedCoffee = coffee;
    }

    public double getCost() {
        return decoratedCoffee.getCost();
    }

    public String getDescription() {
        return decoratedCoffee.getDescription();
    }
}

// 具体装饰器
public class MilkDecorator extends CoffeeDecorator {
    public MilkDecorator(Coffee coffee) {
        super(coffee);
    }

    public double getCost() {
        return super.getCost() + 0.5;
    }

    public String getDescription() {
        return super.getDescription() + ", Milk";
    }
}

public class SugarDecorator extends CoffeeDecorator {
    public SugarDecorator(Coffee coffee) {
        super(coffee);
    }

    public double getCost() {
        return super.getCost() + 0.2;
    }

    public String getDescription() {
        return super.getDescription() + ", Sugar";
    }
}
```
### 应用
- 需要在不改变对象自身的情况下，给对象添加额外的功能
- 需要动态地给一个对象添加职责，而不是通过继承
- 当需要扩展一个类的功能时，装饰器模式比生成子类更灵活

---
## 定义