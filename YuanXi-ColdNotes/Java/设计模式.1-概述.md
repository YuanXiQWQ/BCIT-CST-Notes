## 概述
### 定义
- 设计模式 (Design Patterns)，是指在面向对象编程的软件设计中，被反复使用的一种代码设计经验。使用设计模式的目的是为了可重用代码，提高代码的可扩展性和可维护性
### 目的
- 代码重用性
	- 相同功能的代码不用多次编写
- 可读性
	- 编程规范性, 便于其他程序员的阅读和理解
- 可扩展性 (可维护性)
	- 方便增加新的功能
- 可靠性
	- 当增加新的功能后, 对原来的功能没有影响
- 高内聚性, 低耦合性
	- 模块内部非常紧密, 但是模块与模块之间很少依赖
	- A 模块出问题, 不要带到 B 模块

## 原则
### 单一职责原则 (Single Responsibility Principle, SRP)
#### 定义
- 一个**类**应该只负责一项职责
- 如果类 A 负责两个不同职责(1, 2), 当职责 1 需求变更而改变 A 时, 可能造成 2 执行错误, 所以需要将 A 的粒度分解为 A1, A2

#### 要点
- 降低类的复杂度, 一个类只负责一项职责
- 提高类的可读性和可维护性
- 降低变更引起的风险
- 通常情况下应当遵守单一职责原则, 只有逻辑足够简单, 才可以在代码级别违反该原则: 只有类中的方法数量足够少, 可以只在方法级别保持单一职责原则

#### 示例
##### 方案一
```java
public calss SingleResponsibilitiy1 {
	public static void main (final String[] args){
		Vehicle vehicle = new Vehicle();
		vehicle.run("摩托车");
		vehicle.run("汽车");
		vehicle.run("飞机");
		vehicle.run("轮船");
	}
}

class Vehicle {
	public void run(String vehicle){
		System.out.println(vehicle + "在路上运行");
	}
}
```
- 方案一不符合单一职责原则: 在类SR1的 `run()` 方法中, 违反了单一职责原则: 天上飞的和地上跑的归为了一类, 即在执行摩托车和汽车时, 方法正常运行, 到了飞机时方法就需要修改了

##### 方案二
```java
public calss SingleResponsibilitiy2 {
	public static void main (final String[] args){
		RoadVehicle rv = new RoadVehicle();
		SkyVehicle sv = new SkyVehicle();
		WaterVehicle wv = new WaterVehicle();
		rv.run("摩托车");
		rv.run("汽车");
		sv.run("飞机");
		wv.run("轮船");
	}
}

class RoadVehicle {
	public void run(String vehicle){
		System.out.println(vehicle + "在路上运行");
	}
}

class SkyVehicle {
	public void run(String vehicle){
		System.out.println(vehicle + "在天上运行");
	}
}

class WaterVehicle {
	public void run(String vehicle){
		System.out.println(vehicle + "在水中运行");
	}
}
```
- 遵守了单一职责原则, 但是改动很大, 即将类分解, 同时修改客户端(`main()`)

##### 方案三
```java
```java
public calss SingleResponsibilitiy3 {
	public static void main (final String[] args){
		Vehicle vehicle = new Vehicle();
		vehicle.run("摩托车");
		vehicle.run("汽车");
		vehicle.runAir("飞机");
		vehicle.runWater("轮船");
	}
}

class Vehicle {
	public void run(String vehicle){
		System.out.println(vehicle + "在路上运行");
	}
	
	public void runAir(String vehicle){
		System.out.println(vehicle + "在天上运行");
	}

	public void runWater(String vehicle){
		System.out.println(vehicle + "在水中运行");
	}
}
```
-  该方案没有对原来的类做大的修改,只是增加了方法
- 虽然没有在类级别上遵守单一职责原则, 但是在方法级别上仍然遵守

### 接口隔离原则 (Interface Segregation Principle, ISP)
#### 定义
- 客户端不应该依赖它不需要的接口
- 假设类 A 通过接口 I1 依赖 B, 类 C 通过接口 I1 依赖 D, 如果 I1 对于类 A 和类 C 来说不是最小接口, 那么类 B 和类 D 必须去实现他们不需要的方法. 按照接口隔离原则, 应当将 I1 拆分为独立的几个接口, 类 A 和类 C 分别与它们需要的接口建立依赖关系.

#### 要点
- 专属接口: 为不同客户端创建专门的接口, 确保每个接口只包含客户端所需的方法
- 降低耦合: 通过拆分接口来降低实现类与接口之间的耦合度, 从而提高系统的灵活性和可维护性
- 遵循接口隔离: 让实现类依赖于最小的接口, 避免使用过于庞大, 通用的接口.

#### 示例
##### 方案一
```java
public class Segregation1{  
  
    public static void main(String[] args) {  
        A a = new A();  
        a.depend1(new B());  
        a.depend2(new B());  
        a.depend3(new B());  
        C c = new C();  
        c.depend1(new D());  
        c.depend4(new D());  
        c.depend5(new D());  
    }  
}  
  
interface Interface1 {  
    void operation1();  
    void operation2();  
    void operation3();  
    void operation4();  
    void operation5();  
}  
  
class B implements Interface1 {  
    @Override  
    public void operation1()  
    {  
        System.out.println("B operation1");  
    }  
  
    @Override  
    public void operation2()  
    {  
        System.out.println("B operation2");  
    }  
  
    @Override  
    public void operation3()  
    {  
        System.out.println("B operation3");  
    }  
  
    // 没用到    
@Override  
    public void operation4()  
    {  
        System.out.println("B operation4");  
    }  
  
    // 没用到    
@Override  
    public void operation5()  
    {  
        System.out.println("B operation5");  
    }  
}  
  
class D implements Interface1 {  
    @Override  
    public void operation1()  
    {  
        System.out.println("D operation1");  
    }  
  
    // 没用到    
@Override  
    public void operation2()  
    {  
        System.out.println("D operation2");  
    }  
  
    // 没用到    
@Override  
    public void operation3()  
    {  
        System.out.println("D operation3");  
    }  
  
    @Override  
    public void operation4()  
    {  
        System.out.println("D operation4");  
    }  
  
    @Override  
    public void operation5()  
    {  
        System.out.println("D operation5");  
    }  
}  
  
// A 类通过接口 Interface1 依赖 B 类, 但是只会用到1,2,3方法  class A {  
    public void depend1(Interface1 i)  
    {  
        i.operation1();  
    }  
  
    public void depend2(Interface1 i)  
    {  
        i.operation2();  
    }  
  
    public void depend3(Interface1 i)  
    {  
        i.operation3();  
    }  
}  
  
// C类通过接口 Interface1 依赖 D 类, 但是只会用到1,4,5方法  class C {  
    public void depend1(Interface1 i)  
    {  
        i.operation1();  
    }  
  
    public void depend4(Interface1 i)  
    {  
        i.operation4();  
    }  
  
    public void depend5(Interface1 i)  
    {  
        i.operation5();  
    }  
}
```
- 类 A 依赖 B 的1,2,3方法, 但是4,5方法没用上; 类 C 依赖 D 的1,4,5方法, 但是2,3没用上
- 不符合接口隔离原则

##### 方案二
```java
public class Segregation2 {  
    public static void main(String[] args) {  
        A a = new A();  
        a.depend1(new B());  
        a.depend2(new B());  
        a.depend3(new B());  
  
        C c = new C();  
        c.depend1(new D());  
        c.depend4(new D());  
        c.depend5(new D());  
    }  
}  
  
interface Interface1 {  
    void operation1();  
}  
  
interface Interface2 {  
    void operation2();  
    void operation3();  
}  
  
interface Interface3{  
    void operation4();  
    void operation5();  
}  
  
class B implements Interface1, Interface2{  
    @Override  
    public void operation1(){  
        System.out.println("operation1");  
    }  
  
    @Override  
    public void operation2(){  
        System.out.println("operation2");  
    }  
  
    @Override  
    public void operation3(){  
        System.out.println("operation3");  
    }  
}  
  
class D implements Interface1, Interface3{  
    @Override  
    public void operation1(){  
        System.out.println("operation1");  
    }  
  
    @Override  
    public void operation4(){  
        System.out.println("operation4");  
    }  
  
    @Override  
    public void operation5(){  
        System.out.println("operation5");  
    }  
}  
  
class A{  
  
    public void depend1(Interface1 i){  
        i.operation1();  
    }  
  
    public void depend2(Interface2 i){  
        i.operation2();  
    }  
  
    public void depend3(Interface2 i){  
        i.operation3();  
    }  
}  
  
class C{  
  
    public void depend1(Interface1 i){  
        i.operation1();  
    }  
  
    public void depend4(Interface3 i){  
        i.operation4();  
    }  
  
    public void depend5(Interface3 i){  
        i.operation5();  
    }  
}
```
- 将接口 I1 分为 I1, I2, I3, 分别定义抽象方法 {O1}, {O2, O3}, {O4, O5}
- A 通过 I1, I2 依赖 B, C 通过 I1, I3 依赖 D, 没有多余的实现方法, 符合接口隔离原则

### 依赖倒转原则 (Dependency Inversion Principle, DIP)
#### 定义
- 高层模块不应该依赖于低层模块，二者都应该依赖于抽象
- 抽象不应该依赖于细节，细节应该依赖于抽象
#### 要点
- **面向接口编程**：代码中不直接依赖具体的实现类，而是依赖接口或抽象类。这样可以通过不同实现类来替换接口，从而轻松地扩展系统功能
- **降低耦合**：通过依赖接口而不是具体实现，使得模块之间的依赖关系由强耦合变成松散耦合，提高系统的可维护性和稳定性
#### 示例
##### 方案一
```java
public class DependecyInversion {  
    public static void main(String[] args)  
    {  
        Person person = new Person();  
        person.receive(new Email());  
    }  
}  
  
class Email {  
    public String getInfo()  
    {  
        return "电子邮件信息: Hello World";  
    }  
}  
  
class Person {  
    public void receive(Email email)  
    {  
        System.out.println(email.getInfo());  
    }  
}
```
- Person 依赖细节类 Email
- 如果获取的对象是微信, 短信等, 则需要新增类, 同时 Person 也要增加相应的接受方法
- 解决思路: 引入一个抽象的接口 IReceiver, 这样 Person 就与接口 IReceiver 发生依赖
- 因为 Email, Weixin, SMS 都属于接受的范围, 只需各自实现 IReceiver 接口即可. 符合依赖倒转原则.

##### 方案二
```java
public class DependecyInversion {  
    public static void main(String[] args)  
    {  
        Person person = new Person();  
        person.receive(new WeiXin());  
        person.receive(new Email());  
        person.receive(new SMS());  
    }  
}  
  
interface IReceiver {  
    public String getInfo();  
}  
  
class WeiXin implements IReceiver {  
    @Override  
    public String getInfo()  
    {  
        return "微信信息: Hello World";  
    }  
}  
  
class Email implements IReceiver {  
    @Override  
    public String getInfo()  
    {  
        return "电子邮件信息: Hello World";  
    }  
}  
  
class SMS implements IReceiver {  
    @Override  
    public String getInfo()  
    {  
        return "短信信息: Hello World";  
    }  
}  
  
class Person {  
    public void receive(IReceiver receiver)  
    {  
        System.out.println(receiver.getInfo());  
    }  
}
```
- 方案二添加了 WeiXin, SMS 类, 但是客户端却不需要有大的改变, 因为 Person 依赖的不是具体细节类, 而是接口, 客户端使用不同方法时只需要使用接口的多态即可.

##### 依赖传递方式
1. 接口传递
```java
// 开关的接口
interface IOpenAndClose{
	// 抽象方法, 接受接口 ITV
	public void open(ITV tv);
}

// ITV接口
interface ITV {
	public void play();
}

// 实现接口 IOpenAndClose, 就意味着必须实现 ITV, 依赖被接口传递
class OpenAndClose implements IOpenAndClose{
	public void open(ITV tv){
		tv.play();
	}
}
```

2. 构造方法
```java
interface IOpenAndClose{
	// 抽象方法
	public void open();
}

// ITV 接口
interface ITV{
	public void play();
}

class OpenAndClose implements IOpenAndClose{
	// 接口成员
	private ITV tv;

	// 构造类的对象时需要传入一个已经实现 ITV 接口的对象来初始化成员变量
	public OpenAndClose(ITV tv){
		this.tv = tv;
	}

	// 使用接受了已经实现 ITV 接口的对象的接口成员实现接口 IOpenAndClose 方法
	public void open(){
		this.tv.play();
	}
}
```

3. Setter 方法
```java
interface IOpenAndClose{
	// 抽象方法
	public void open();

	public void setTv(ITV tv);
}

// ITV 接口
interface ITV{
	public void play();
}

class OpenAndClose implements IOpenAndClose{
	// 接口成员
	private Itv tv;

	// 需要传入一个已经实现 ITV 接口的对象来初始化成员变量
	public boid setTv(ITV tv){
		this.tv = tv;
	}

	// 使用接受了已经实现 ITV 接口的对象的接口成员实现接口 IOpenAndClose 方法
	public void open() {
		this.tv.play();
	}
}
```
### 里氏替换原则 (Liskov Substitution Principle, LSP)
#### 定义
- 子类对象能够替换父类对象, 并且程序功能不受影响
	- 继承在增加代码复用的同时也增加了对象之间的耦合性. 如果类 A 被 B, C 继承, 当 A 修改时, 必须考虑到 B, C. 并且父类在修改后, 所有涉及到子类的功能都有可能产生故障.
	- 尽量不要重写父类方法, 如果一定要重写, 可以让子类与父类同时继承一个更基础的类, 使其耦合性降低

#### 要点
- **行为一致性**：子类在继承父类时，应该保持父类的行为一致，不应改变父类方法的预期行为
- **方法签名**：子类方法的签名（参数和返回类型）应与父类保持一致，或在允许的范围内进行扩展。
- **前置条件和后置条件**：
    - **前置条件**：子类方法的前置条件不能比父类更严格。
    - **后置条件**：子类方法的后置条件不能比父类更宽松。
- **不可破坏继承关系**：子类不应该破坏父类的抽象，确保继承关系的正确性。

#### 示例
##### 方案一
```java
public class Liskov {  
  
    public static void main(String[] args) {  
        A a = new A();  
        // 11 - 3 = 8  
        System.out.println("11-3=" + a.func1(11, 3));  
        // 1 - 8 = -7  
        System.out.println("1-8=" + a.func1(1, 8));  
  
        System.out.println("--------------------");  
        B b = new B();  
        // 本应是 11 - 3 = 8, 由于重写了func1, 变成了 11 + 3 = 14        System.out.println("11-3=" + b.func1(11, 3));  
        // 本应是 1 - 8 = -7, 由于重写了func1, 变成了 1 + 8 = 9        System.out.println("1-8=" + b.func1(1, 8));  
        // 11 + 3 + 9 = 23  
        System.out.println("11+3+9=" + b.func2(11, 3));  
    }  
}  
  
// 返回两个数的差  
class A {  
    public int func1(int a, int b)  
    {  
        return a - b;  
    }  
}  
  
// 继承了A, 增加一个新功能: 完成两个数相加, 然后再加9  
class B extends A {  
    // 这里不小心重写了 func1(), 不再满足里氏替换原则  
    @Override  
    public int func1(int a, int b)  
    {  
        return a + b;  
    }  
  
    public int func2(int a, int b)  
    {  
        return func1(a, b) + 9;  
    }  
}
```
- 由于 B 不小心重写了 `func1()`, 不再满足里氏替换原则, 导致结果出错

##### 方案二
```java
public class Liskov {  
  
    public static void main(String[] args) {  
        A a = new A();  
        // 11 - 3 = 8  
        System.out.println("11-3=" + a.func1(11, 3));  
        // 1 - 8 = -7  
        System.out.println("1-8=" + a.func1(1, 8));  
  
        System.out.println("--------------------");  
        B b = new B();  
        // 11 - 3 = 8  
        System.out.println("11-3=" + b.func3(11, 3));  
        // 1 - 8 = -7  
        System.out.println("1-8=" + b.func3(1, 8));  
        // 11 + 3 + 9 = 23  
        System.out.println("11+3+9=" + b.func2(11, 3));  
    }  
}  
  
// 创建一个更加基础的类  
class Base {  
    public int func1(int a, int b)  
    {  
        return a - b;  
    }  
}  
  
// 返回两个数的差  
class A extends Base {  
    @Override  
    public int func1(int a, int b)  
    {  
        return super.func1(a, b);  
    }  
}  
  
class B extends Base {  
    @Override  
    public int func1(int a, int b)  
    {  
        return a + b;  
    }  
  
    public int func2(int a, int b)  
    {  
        return func1(a, b) + 9;  
    }  
    // 如果 B 想使用 A 的方法, 可以使用组合关系  
    private final A a = new A();  
  
    // 仍然用到 A 的方法  
    public int func3(int a, int b)  
    {  
        return this.a.func1(a, b);  
    }  
}
```
- 因为 B 不再继承 A , 因此调用者不会再认为 b.func1 是减法了
- 调用完成的功能很明确, 并且使用组合仍然可以使用到 A 的方法  

### 开闭原则
#### 定义
-  软件应该对可扩展开放, 而对修改关闭
- 增加新功能的时候，如果只增加代码就完成了新功能
#### 要点

#### 示例

### 迪米特法原则
#### 定义

#### 要点

#### 示例

### 合成复用原则
#### 定义

#### 要点

#### 示例