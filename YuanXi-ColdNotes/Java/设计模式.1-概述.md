## 概述
### 定义
- 设计模式 (Design Patterns)，是指在面向对象编程的软件设计中，被反复使用的一种代码设计经验。使用设计模式的目的是为了可重用代码，提高代码的可扩展性和可维护性
### 目的
- 代码重用性
	- 相同功能的代码不用多次编写
- 可读性
	- 编程规范性, 便于其他程序员的阅读和理解
- 可扩展性 (可维护性)
	- 方便增加新的功能
- 可靠性
	- 当增加新的功能后, 对原来的功能没有影响
- 高内聚性, 低耦合性
	- 模块内部非常紧密, 但是模块与模块之间很少依赖
	- A 模块出问题, 不要带到 B 模块

## 原则
### 单一职责原则 (Single Responsibility Principle, SRP)
#### 定义
- 一个**类**应该只负责一项职责
- 如果类 A 负责两个不同职责(1, 2), 当职责 1 需求变更而改变 A 时, 可能造成 2 执行错误, 所以需要将 A 的粒度分解为 A1, A2

#### 要点
- 降低类的复杂度, 一个类只负责一项职责
- 提高类的可读性和可维护性
- 降低变更引起的风险
- 通常情况下应当遵守单一职责原则, 只有逻辑足够简单, 才可以在代码级别违反该原则: 只有类中的方法数量足够少, 可以只在方法级别保持单一职责原则

#### 示例
##### 方案一
```java
public calss SingleResponsibilitiy1 {
	public static void main (final String[] args){
		Vehicle vehicle = new Vehicle();
		vehicle.run("摩托车");
		vehicle.run("汽车");
		vehicle.run("飞机");
		vehicle.run("轮船");
	}
}

class Vehicle {
	public void run(String vehicle){
		System.out.println(vehicle + "在路上运行");
	}
}
```
- 方案一不符合单一职责原则: 在类SR1的 `run()` 方法中, 违反了单一职责原则: 天上飞的和地上跑的归为了一类, 即在执行摩托车和汽车时, 方法正常运行, 到了飞机时方法就需要修改了

##### 方案二
```java
public calss SingleResponsibilitiy2 {
	public static void main (final String[] args){
		RoadVehicle rv = new RoadVehicle();
		SkyVehicle sv = new SkyVehicle();
		WaterVehicle wv = new WaterVehicle();
		rv.run("摩托车");
		rv.run("汽车");
		sv.run("飞机");
		wv.run("轮船");
	}
}

class RoadVehicle {
	public void run(String vehicle){
		System.out.println(vehicle + "在路上运行");
	}
}

class SkyVehicle {
	public void run(String vehicle){
		System.out.println(vehicle + "在天上运行");
	}
}

class WaterVehicle {
	public void run(String vehicle){
		System.out.println(vehicle + "在水中运行");
	}
}
```
- 遵守了单一职责原则, 但是改动很大, 即将类分解, 同时修改客户端(`main()`)

##### 方案三
```java
```java
public calss SingleResponsibilitiy3 {
	public static void main (final String[] args){
		Vehicle vehicle = new Vehicle();
		vehicle.run("摩托车");
		vehicle.run("汽车");
		vehicle.runAir("飞机");
		vehicle.runWater("轮船");
	}
}

class Vehicle {
	public void run(String vehicle){
		System.out.println(vehicle + "在路上运行");
	}
	
	public void runAir(String vehicle){
		System.out.println(vehicle + "在天上运行");
	}

	public void runWater(String vehicle){
		System.out.println(vehicle + "在水中运行");
	}
}
```
-  该方案没有对原来的类做大的修改,只是增加了方法
- 虽然没有在类级别上遵守单一职责原则, 但是在方法级别上仍然遵守
### 接口隔离原则 (Interface Segregation Principle, ISP)
#### 定义
- 客户端不应该依赖它不需要的接口
- 假设类 A 通过接口 I1 依赖 B, 类 C 通过接口 I1 依赖 D, 如果 I1 对于类 A 和类 C 来说不是最小接口, 那么类 B 和类 D 必须去实现他们不需要的方法. 按照接口隔离原则, 应当将 I1 拆分为独立的几个接口, 类 A 和类 C 分别与它们需要的接口建立依赖关系.

#### 要点
- 专属接口: 为不同客户端创建专门的接口, 确保每个接口只包含客户端所需的方法
- 降低耦合: 通过拆分接口来降低实现类与接口之间的耦合度, 从而提高系统的灵活性和可维护性
- 遵循接口隔离: 让实现类依赖于最小的接口, 避免使用过于庞大, 通用的接口.

#### 示例
##### 方案一
```java
public class Segregation1{  
  
    public static void main(String[] args) {  
        A a = new A();  
        a.depend1(new B());  
        a.depend2(new B());  
        a.depend3(new B());  
        C c = new C();  
        c.depend1(new D());  
        c.depend4(new D());  
        c.depend5(new D());  
    }  
}  
  
interface Interface1 {  
    void operation1();  
    void operation2();  
    void operation3();  
    void operation4();  
    void operation5();  
}  
  
class B implements Interface1 {  
    @Override  
    public void operation1()  
    {  
        System.out.println("B operation1");  
    }  
  
    @Override  
    public void operation2()  
    {  
        System.out.println("B operation2");  
    }  
  
    @Override  
    public void operation3()  
    {  
        System.out.println("B operation3");  
    }  
  
    // 没用到    
@Override  
    public void operation4()  
    {  
        System.out.println("B operation4");  
    }  
  
    // 没用到    
@Override  
    public void operation5()  
    {  
        System.out.println("B operation5");  
    }  
}  
  
class D implements Interface1 {  
    @Override  
    public void operation1()  
    {  
        System.out.println("D operation1");  
    }  
  
    // 没用到    
@Override  
    public void operation2()  
    {  
        System.out.println("D operation2");  
    }  
  
    // 没用到    
@Override  
    public void operation3()  
    {  
        System.out.println("D operation3");  
    }  
  
    @Override  
    public void operation4()  
    {  
        System.out.println("D operation4");  
    }  
  
    @Override  
    public void operation5()  
    {  
        System.out.println("D operation5");  
    }  
}  
  
// A 类通过接口 Interface1 依赖 B 类, 但是只会用到1,2,3方法  class A {  
    public void depend1(Interface1 i)  
    {  
        i.operation1();  
    }  
  
    public void depend2(Interface1 i)  
    {  
        i.operation2();  
    }  
  
    public void depend3(Interface1 i)  
    {  
        i.operation3();  
    }  
}  
  
// C类通过接口 Interface1 依赖 D 类, 但是只会用到1,4,5方法  class C {  
    public void depend1(Interface1 i)  
    {  
        i.operation1();  
    }  
  
    public void depend4(Interface1 i)  
    {  
        i.operation4();  
    }  
  
    public void depend5(Interface1 i)  
    {  
        i.operation5();  
    }  
}
```
- 类 A 依赖 B 的1,2,3方法, 但是4,5方法没用上; 类 C 依赖 D 的1,4,5方法, 但是2,3没用上
- 不符合接口隔离原则

##### 方案二
```java
public class Segregation2 {  
    public static void main(String[] args) {  
        A a = new A();  
        a.depend1(new B());  
        a.depend2(new B());  
        a.depend3(new B());  
  
        C c = new C();  
        c.depend1(new D());  
        c.depend4(new D());  
        c.depend5(new D());  
    }  
}  
  
interface Interface1 {  
    void operation1();  
}  
  
interface Interface2 {  
    void operation2();  
    void operation3();  
}  
  
interface Interface3{  
    void operation4();  
    void operation5();  
}  
  
class B implements Interface1, Interface2{  
    @Override  
    public void operation1(){  
        System.out.println("operation1");  
    }  
  
    @Override  
    public void operation2(){  
        System.out.println("operation2");  
    }  
  
    @Override  
    public void operation3(){  
        System.out.println("operation3");  
    }  
}  
  
class D implements Interface1, Interface3{  
    @Override  
    public void operation1(){  
        System.out.println("operation1");  
    }  
  
    @Override  
    public void operation4(){  
        System.out.println("operation4");  
    }  
  
    @Override  
    public void operation5(){  
        System.out.println("operation5");  
    }  
}  
  
class A{  
  
    public void depend1(Interface1 i){  
        i.operation1();  
    }  
  
    public void depend2(Interface2 i){  
        i.operation2();  
    }  
  
    public void depend3(Interface2 i){  
        i.operation3();  
    }  
}  
  
class C{  
  
    public void depend1(Interface1 i){  
        i.operation1();  
    }  
  
    public void depend4(Interface3 i){  
        i.operation4();  
    }  
  
    public void depend5(Interface3 i){  
        i.operation5();  
    }  
}
```
- 将接口 I1 分为 I1, I2, I3, 分别定义抽象方法 {O1}, {O2, O3}, {O4, O5}
- A 通过 I1, I2 依赖 B, C 通过 I1, I3 依赖 D, 没有多余的实现方法, 符合接口隔离原则
### 依赖倒转原则 (Dependency Inversion Principle, DIP)
#### 定义
- 高层模块不应该依赖于低层模块，二者都应该依赖于抽象
- 抽象不应该依赖于细节，细节应该依赖于抽象
#### 要点
- **面向接口编程**：代码中不直接依赖具体的实现类，而是依赖接口或抽象类。这样可以通过不同实现类来替换接口，从而轻松地扩展系统功能。
- **降低耦合**：通过依赖接口而不是具体实现，使得模块之间的依赖关系由强耦合变成松散耦合，提高系统的可维护性和稳定性。

#### 示例
### 里氏替换原则
#### 定义

#### 要点

#### 示例
### 开闭原则
#### 定义

#### 要点

#### 示例
	- 软件应该对可扩展开放, 而对修改关闭
	- 增加新功能的时候，如果只增加代码就完成了新功能
### 迪米特法原则
#### 定义

#### 要点

#### 示例
### 合成复用原则
#### 定义

#### 要点

#### 示例